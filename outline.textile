Erlang's Chicken-and-Egg Problem
* Need the experience to get the job...
** Scalable distributed systems
** Weird language: not-C, immutable, no for loop
** roadmap: worth learning, getting over the hump, gaining experience

* Worth learning for its own sake
** foreign travel: day trip v stay
** meta-learning/adaptability
** less freaked out by syntax: Coffeescript, Objective-C
** functional problem-solving (bowling game)
*** division of responsibility; complexity begets complexity
*** list of numbers -> single number: fold function
*** back to Python
** Backbone.js & Coffeescript
** the Erlang community is still small enough to be awesome

* Over the hump
** syntax - you will get used to it
*** not C but English; functions are sentences
*** control structures are functions

** recursion: rare in OO, everywhere in Erlang
*** synergistic weirdness: immutable variables, pattern matching
*** beginning, end, middle
*** pattern matching
*** libraries: lists, proplists

** processes & IPC: again, rare in OO, everywhere in Erlang
*** more OO than OO: objects -> processes
*** e.g. file handles
*** gen_server, gen_event

* gaining experience
** scripting
** testing tools
*** mock web service

** simple web apps
*** ChicagoBoss, nitrogen, spooky, webmachine


** use on personal projects
*** simple web apps
**** ChicagoBoss, nitrogen, spooky, webmachine
** non-critical apps
*** escript
*** testing tools: web services
*** mock services
** read other people's source
*** I've contributed *minor* patches to both Spooky and Erlydtl
*** odds are you'll find something you need to fix or extend
** There are two sides to learning Erlang: the language itself, and building and deploying complex applications.
*** Honestly, I haven't cracked the second half of that problem.

